<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>

<h3>dom渲染频繁，解决页面卡顿。</h3>
<p>渲染结果：<b id="myDiv">0</b></p>
<button onclick="btn0()">btn0 卡顿</button>
<button onclick="btn00()">btn00 抽样渲染</button>
|---
<button onclick="btn1()">setTimeout</button>
<button onclick="btn2()">setInterval</button>
<button onclick="btn3()">requestAnimationFrame</button>
<button onclick="btn4()">stop</button>
</div>

<script>
//---------------------------

//IE9 严格兼容
// if(!window.requestAnimationFrame){
//     var lastTime = 0;
//     window.requestAnimationFrame = function(callback){
//         var currTime = new Date().getTime();
//         var timeToCall = Math.max(0, 16.7 - (currTime - lastTime));
//         var id  = window.setTimeout(function(){
//             callback(currTime + timeToCall);
//         },timeToCall);
//         lastTime = currTime + timeToCall;
//         return id;
//     }
// }
// if (!window.cancelAnimationFrame) {
//     window.cancelAnimationFrame = function(id) {
//         clearTimeout(id);
//     };
// }
// setTimeout()：在特定的时间后执行函数，而且只执行一次，如果在特定时间前想取消执行函数，
// 可以用clearTimeout立即取消执行。但是并不是每次执行setTimeout都会在特定的时间后执行，
// 页面加载后js会按照主线程中的顺序按序执行那个，如果在延迟时间内主线程不空闲，setTimeout
// 里面的函数是不会执行的，它会延迟到主线程空闲时才执行。
// setInterval()：在特定的时间间隔内重复执行函数，除非主动清除它，不然会一直执行下去，
// 清除函数可以使用clearInterval。setInterval也会等到主线程空闲了再执行，但是setInterval
// 去排队时，如果发现自己还在队列中未执行，就会被drop掉，所以可能会造成某段时间的函数未被执行。
// requestAnimationFrame()：它不需要设置时间间隔，它会在浏览器每次刷新之前执行回调函数的任务。
// 这样我们动画的更新就能和浏览器的刷新频率保持一致。requestAnimationFrame在运行时，浏览器会自动
// 优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。

//---------------------------

const myDiv = document.getElementById('myDiv')
let temp;
let timer;


//----------------------------卡顿，(最后渲染一次输出)
function btn0(){
    temp = 0;

    for (let i = 0; i < 500000; i++) {//同步速度快。（3秒左后会卡，什么操作也做不了。主线程被堵塞了）
        temp = i;
        // myDiv.innerHTML=temp;//太快了，渲染不了。卡，最终输出最后的结果。
        if(i%10000==0){
            console.log(i)
            // myDiv.style.display = 'none';
            // myDiv.style.display = 'block';
            // forceRedraw(myDiv)
            myDiv.innerHTML=temp;
            refresh(myDiv)
            
        } 

    }
}


function btn00(){
    let timer1, timer2;
    temp = 0;
    count=300;//计算300次
    delayOut = 100;//抽样输出间隔
    console.time('btn00')
    clearInterval(timer1);
    clearInterval(timer2);
    btn4();
    //模拟异步反馈数据（worker传来的数据）
    timer1 = setInterval(function fn(){//无限循环    
        if(temp < count){
            temp++;
        }else{
            clearInterval(timer1);//终止循环
        }
    });
    //抽样渲染
    timer2 = setInterval(function fn(){//无限循环    
        // console.log(temp);       //!!
        myDiv.innerHTML = temp;     //!!dom操作
        if(temp > count){
            console.timeEnd('btn00')
            clearInterval(timer2);//终止循环
        }
    }, delayOut);
}


//---------------------不卡，（实时更新数据）

function btn1() {//setTimeout 延迟执行一次
    let temp = 0;
    let delay = 0;//延迟16毫秒
    let count = 300; //渲染300次
    console.time('setTimeout')
    clearInterval(timer);
    timer = setTimeout(function fn(){//执行一次
        myDiv.innerHTML = temp + 1;         //!!dom操作
        temp=parseInt(myDiv.innerHTML);     //!!
        if(temp < count){
            timer = setTimeout(fn, delay);//再循环一次
        }else{
            console.timeEnd('setTimeout')
            clearTimeout(timer);//终止循环
        }
    }, delay);
}


function btn2() {//setInterval 延迟无限循环
    let temp = 0;
    let count = 300; //渲染300次
    console.time('setInterval')
    clearInterval(timer);
    timer = setInterval(function fn(){//无限循环
        myDiv.innerHTML = temp + 1;         //!!dom操作
        temp=parseInt(myDiv.innerHTML);     //!!
        if(temp > count){
            console.timeEnd('setInterval')
            clearInterval(timer);//终止循环
        }
    });
}


function btn3(){//requestAnimationFrame (逐帧无限执行，无延迟)
    // let temp = 0;
    // let count = 300; //渲染300次
    // console.time('requestAnimationFrame')
    // cancelAnimationFrame(timer);
    // timer = requestAnimationFrame(function fn(){
    //     myDiv.innerHTML = temp + 1;         //!!dom操作
    //     temp=parseInt(myDiv.innerHTML);     //!!
    //     if(temp < count){
    //         timer = requestAnimationFrame(fn);
    //     }else{
    //         console.timeEnd('requestAnimationFrame')
    //         cancelAnimationFrame(timer);
    //     }
    // });
    rendering(function(n){
        myDiv.innerHTML = parseInt(myDiv.innerHTML) + 1
    },1)

}

        function rendering(callback, count=100){//requestAnimationFrame (逐帧无限执行，无延迟)
            let temp = 0;
            // console.time('requestAnimationFrame')
            cancelAnimationFrame(timer);
            timer = requestAnimationFrame(function fn(){
                if(temp < count){
                    timer = requestAnimationFrame(fn);
                    callback(temp);
                    temp++;
                    // console.log(temp)
                }else{
                    // console.timeEnd('requestAnimationFrame')
                    cancelAnimationFrame(timer);
                }
            });
        }
        // rendering(function(n){
        //     myDiv.innerHTML = n+1
        // },100)
        // rendering(function(n){
        //     myDiv.innerHTML = parseInt(myDiv.innerHTML) + 1
        // },1)




function btn4(){//stop
    clearTimeout(timer);
    clearInterval(timer);
    cancelAnimationFrame(timer);
}
//结果：
// 23:33:53.421 loopdom.html:115 setInterval: 1192.746826171875ms
// 23:34:00.679 loopdom.html:133 requestAnimationFrame: 4979.468994140625ms
// 23:34:09.389 loopdom.html:100 setTimeout: 5114.701904296875ms







//------------------------------下面是 推荐的方法---------------------------------------
</script>


<hr>
<pre>
    推荐方法：
    <div id="rebox2"></div>
    <div id="rebox"></div>
</pre>
<button onclick="exp_refreshFor()">exp_refreshFor()</button>

<script>


refreshFun(function(){
    console.log('1111');
})
refreshFun(function(){
    console.log('2222');
    // for (let i = 0; i < 400000; i++) {//대략 5초 동안 일함. (화면 끊김현상 있음)[동기]
    //     $('#rebox').html(i +'/'+ 100)
    // }
    refreshFor(0, 50, function(i,leng){//[비동기]
        rebox2.innerHTML = (i+1) +'/'+ leng ; 
    },50)

})
refreshFun(function(){
    console.log('3333');
})

waitFun()


//실행할 리스트
function refreshFun(callback){//비동기로 실행할 로직을 대기만 한다. 
    if(typeof window.fun == 'undefined') fun = {}
    if(typeof window.timeList == 'undefined')  timeList = [];
    let leng=timeList.length;
    name = 'timeFun_'+timeList.length;
    fun[name] = callback;
    timeList.push([name,false]);
    // console.log(fun[name], timeList, leng )
}
// fun.A()
// fun.B()

// console.log(timeList)

//실행
function waitFun(){//순차적으로 실행
    let runname = timeList[0][0];
    if(timeList.length == 0 || typeof fun[runname] == 'undefined' ) return;
    // console.log(timeList[0][0], timeList[0][1], typeof fun[runname], timeList.length)
    runTimer = setInterval(function(){
        console.log('----------',timeList.length)
        if(timeList.length == 0 ){//모든 할일을 다 했을때
            clearInterval(runTimer);//더 이상 탐지 하지 않는다.
            delete timeList;
            delete fun;
        } else {//해야할 임무가 있을때
            runname = timeList[0][0];
            if(timeList[0][1] ==false && timeList[0][0] == runname){//실행중이 아니면 실행
                // console.log('실행중이 아니면')
                timer = setTimeout(function(){
                    timeList[0][1] = true;//현재 실행중입니다.
                    fun[runname]();//함수실행
                    delete fun[runname];//다실행하고 지움
                    timeList.shift();
                });//딜레이 없이 바로실행
            }else{//실행중이 이면 아무것도 안함.
                // console.log('실행중입니다.')
            }
        }
    },20);//ms간격으로 끝났는지 여부 확인해본다. (너무 짧으면 Uncaught ReferenceError: timeList is not defined 에러날수 있음)
}








//---------------


//예제
function exp_refreshFor(){
    refreshFun(function(){//순차적으로 기다림.
        refreshFor(0, 3, function(i,leng){

            $(rebox).append( 'A__'+ (i+1)+'/'+ leng +'<br>');

            refreshFun(function(){//순차적으로 기다림.
                refreshFor(0, 5, function(j,leng2){

                    $(rebox).append('   B__'+ (j+1) +'/'+ leng2 +'<br>')
                    rebox2.innerHTML = (i+1) +'/'+ leng +'_'+ (j+1) + '/'+ leng2 +'_'+ ((i+1)*j); 

                })
            })
            waitFun()
            

        },100);//예측시간
    })
    waitFun()
}


//(DOM 강제 렌더링) (模拟for语句)
function refreshFor( n=0, count=100, callback, delay=0) { //n=i , count=length
    let consoletime = 'setTimeout_'+n+'/'+count+'_'+delay;
    console.time(consoletime);//시간기록
    timer = setTimeout(function fn(){//한번실행
        if(n < count){
            callback(n, count);
            timer = setTimeout(fn, delay);//재실행
        }
        else{
            clearTimeout(timer);//끝내기.
            console.timeEnd(consoletime);//기록한시간출력. (delay설정방법: 여러번 테스트후의 예측시간 이상으로 설정해주기)
        }
        n++;
    }, delay);
}

//------
// function refreshFor2( n=0, count=100, callback, delay=0) {
//     let consoletime = 'setInterval_'+n+'/'+count+'_'+delay;
//     console.time(consoletime);//시간기록
//     timer = setInterval(function fn(){//한번실행
//         if(n < count){
//             callback(n, count);
//         }else{
//             clearInterval(timer);//끝내기.
//             console.timeEnd(consoletime);//기록한시간출력. (delay설정방법: 여러번 테스트후의 예측시간 이상으로 설정해주기)
//         }
//         n++;
//     }, delay);
// }
//------
// requestAnimationFrame방식은 delay설정을 할수 없어서 복측구조실행은 안됨.
//------


</script>




