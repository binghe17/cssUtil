<h3>dom渲染频繁，解决页面卡顿。</h3>
<p>渲染结果：<b id="myDiv">0</b></p>
<button onclick="btn0()">btn0 卡顿</button>
<button onclick="btn00()">btn00 抽样渲染</button>
|---
<button onclick="btn1()">setTimeout</button>
<button onclick="btn2()">setInterval</button>
<button onclick="btn3()">requestAnimationFrame</button>
<button onclick="btn4()">stop</button>
</div>

<script>
//IE9 严格兼容
// if(!window.requestAnimationFrame){
//     var lastTime = 0;
//     window.requestAnimationFrame = function(callback){
//         var currTime = new Date().getTime();
//         var timeToCall = Math.max(0, 16.7 - (currTime - lastTime));
//         var id  = window.setTimeout(function(){
//             callback(currTime + timeToCall);
//         },timeToCall);
//         lastTime = currTime + timeToCall;
//         return id;
//     }
// }
// if (!window.cancelAnimationFrame) {
//     window.cancelAnimationFrame = function(id) {
//         clearTimeout(id);
//     };
// }

// setTimeout()：在特定的时间后执行函数，而且只执行一次，如果在特定时间前想取消执行函数，
// 可以用clearTimeout立即取消执行。但是并不是每次执行setTimeout都会在特定的时间后执行，
// 页面加载后js会按照主线程中的顺序按序执行那个，如果在延迟时间内主线程不空闲，setTimeout
// 里面的函数是不会执行的，它会延迟到主线程空闲时才执行。

// setInterval()：在特定的时间间隔内重复执行函数，除非主动清除它，不然会一直执行下去，
// 清除函数可以使用clearInterval。setInterval也会等到主线程空闲了再执行，但是setInterval
// 去排队时，如果发现自己还在队列中未执行，就会被drop掉，所以可能会造成某段时间的函数未被执行。

// requestAnimationFrame()：它不需要设置时间间隔，它会在浏览器每次刷新之前执行回调函数的任务。
// 这样我们动画的更新就能和浏览器的刷新频率保持一致。requestAnimationFrame在运行时，浏览器会自动
// 优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。


const myDiv = document.getElementById('myDiv')
let temp;
let timer;

//卡顿，最后一次渲染输出
function btn0(){
    temp = 0;
    for (let i = 0; i < 500000; i++) {//同步速度快。（3秒左后会卡，什么操作也做不了。主线程被堵塞了）
        temp = i;
        myDiv.innerHTML=temp;//太快了，渲染不了。卡，最终输出最后的结果。
    }
}
function btn00(){
    let timer1, timer2;
    temp = 0;
    count=300;//计算300次
    delayOut = 100;//抽样输出间隔

    console.time('btn00')
    clearInterval(timer1);
    clearInterval(timer2);
    btn4();
    //模拟异步反馈数据（worker传来的数据）
    timer1 = setInterval(function fn(){//无限循环    
        if(temp < count){
            temp++;
        }else{
            clearInterval(timer1);//终止循环
        }
    });

    //抽样渲染
    timer2 = setInterval(function fn(){//无限循环    
        // console.log(temp);       //!!
        myDiv.innerHTML = temp;     //!!dom操作
        if(temp > count){
            console.timeEnd('btn00')
            clearInterval(timer2);//终止循环
        }
    }, delayOut);
}

//实时更新数据
function btn1() {//setTimeout 延迟执行一次
    let temp = 0;
    let delay = 16;//延迟16毫秒
    let count = 300; //渲染300次
    console.time('setTimeout')
    clearInterval(timer);
    timer = setTimeout(function fn(){//执行一次
        myDiv.innerHTML = temp + 1;         //!!dom操作
        temp=parseInt(myDiv.innerHTML);     //!!
        if(temp < count){
            timer = setTimeout(fn, delay);//再循环一次
        }else{
            console.timeEnd('setTimeout')
            clearTimeout(timer);//终止循环
        }
    }, delay);

}
function btn2() {//setInterval 延迟无限循环
    let temp = 0;
    let count = 300; //渲染300次
    console.time('setInterval')
    clearInterval(timer);
    timer = setInterval(function fn(){//无限循环
        myDiv.innerHTML = temp + 1;         //!!dom操作
        temp=parseInt(myDiv.innerHTML);     //!!
        if(temp > count){
            console.timeEnd('setInterval')
            clearInterval(timer);//终止循环
        }
    });

}

function btn3(){//requestAnimationFrame (逐帧无限执行，无延迟)
    let temp = 0;
    let count = 300; //渲染300次
    console.time('requestAnimationFrame')
    cancelAnimationFrame(timer);
    timer = requestAnimationFrame(function fn(){
        myDiv.innerHTML = temp + 1;         //!!dom操作
        temp=parseInt(myDiv.innerHTML);     //!!
        if(temp < count){
            timer = requestAnimationFrame(fn);
        }else{
            console.timeEnd('requestAnimationFrame')
            cancelAnimationFrame(timer);
        }
    });
}

function btn4(){//stop
    clearTimeout(timer);
    clearInterval(timer);
    cancelAnimationFrame(timer);
}

//结果：
// 23:33:53.421 loopdom.html:115 setInterval: 1192.746826171875ms
// 23:34:00.679 loopdom.html:133 requestAnimationFrame: 4979.468994140625ms
// 23:34:09.389 loopdom.html:100 setTimeout: 5114.701904296875ms

</script>


